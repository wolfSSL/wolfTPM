#!/bin/bash
# shellcheck disable=SC2034 # shellcheck doesn't understand ${!varref} syntax.

cloc_lang_def=cloc_lang_def.txt

do178_filtered_tree=do178_trimmed_sources

set -o noclobber -o nounset -o pipefail || exit $?
shopt -s extglob lastpipe || exit $?

if [[ $# -ge 2 ]]; then
    user_settings="$1"
elif [[ -r include/user_settings.h ]]; then
    user_settings=include/user_settings.h
elif [[ -r wolftpm/options.h ]]; then
    user_settings=wolftpm/options.h
else
    echo 'No configuration found.' 1>&2
    exit 1
fi

echo "Using configuration in ${user_settings}."

if [[ -v user_settings && ! -r "$user_settings" ]]; then
    echo "${user_settings} not readable." >&2
    exit 1
fi

# flags that should always be set:
always_settings=(
    -DHAVE_DO178
)



# don't add autogenerated files to $do178_filtered_tree
declare -A excluded_filenames
excluded_filenames=(
    [wolftpm/tpm2_linux.h]=''
    [wolftpm/tpm2_swtpm.h]=''
    [wolftpm/tpm2_winapi.h]=''
    [wolftpm/options.h]=''
    [src/config.h]=''
    [src/tpm2_cryptocb.c]=''
    [src/tpm2_linux.c]=''
    [hal/tpm_io_linux.c]=''
    [hal/tpm_io.c]=''
    [hal/tpm_io.h]=''
)

declare -A ignore_unregen_filenames
ignore_unregen_filenames=(
    [lib/wolfssl/wolfcrypt/src/coding.c]=''
)

# Define required defines that should never be excluded
declare -A required_defines
required_defines=(
    [HAVE_CONFIG_H]=''
    [__cplusplus]=''
)

 #   [__linux__]=''

declare -A excluded_defines
excluded_defines=(
    [__linux__]=''
    [WOLFTPM_I2C]=''
    [WOLFTPM_MICROCHIP]=''
    [WOLFTPM_SLB9670]=''
    [WOLFTPM_SLB9672]=''
    [WOLFTPM_NUVOTON]=''
    [WOLFTPM2_CERT_GEN]=''
    [WOLFTPM_DEBUG_VERBOSE]=''
    [DEBUG]=''
    [DEBUG_WOLFTPM]=''
    [DEBUG_WOLFSSL]=''
    [DEBUG_WOLFSSL_VERBOSE]=''
    [WOLFSSL_DEBUG_MEMORY]=''
    [WOLFTPM_DEBUG_TIMEOUT]=''
    [WOLFTPM_DEBUG_IO]=''
)

function cleanup() {
    rm -f /tmp/wolfcrypt_user_settings_filtered.h.$$
    rm -rf /tmp/do178_filtered_tree.stage2.$$
    echo
}
trap cleanup EXIT

function filter_out_cpp_conditionals() {
    awk '
    BEGIN {
        ifdepth=0;
    }
    /^[ \t]*#[ \t]*if/ {
        ++ifdepth;
        next;
    }
    /^[ \t]*#[ \t]*endif/ {
        --ifdepth;
        next;
    }
    {
        if (ifdepth == 0) {
            print;
        }
    }
    END {
        if (ifdepth == 0) {
            exit(0);
        } else {
            print "unbalanced ifdepth" >"/dev/stderr";
            exit(1);
        }
    }'
}

function join_cpp_line_continuations() {
    awk '
    BEGIN {
        in_cpp_continuation=0;
    }

    # insert a line break before the start of a multi-line comment that starts on a preprocessor line:
    {
        if (match($0, "^( *#.*)(/\\*.*)$", cpp_with_comment_a) && ($0 !~ "\\*/")) {
            gsub(" +$", "", cpp_with_comment_a[1]);
            printf("%s\n% *s%s\n", cpp_with_comment_a[1], length(cpp_with_comment_a[1]), "", cpp_with_comment_a[2]);
            next;
        }
    }

    # unifdef only cares about the starts of conditionals:
    /^ *#(if|else|elif).*\\$/ {
        in_cpp_continuation=1;
    }

    {
        if (in_cpp_continuation) {
            if (match($0, "^( +#.*)\\\\$", trimmed_cont_line_a)) {
                gsub(" +$", "", trimmed_cont_line_a[1]);
                printf("%s ", trimmed_cont_line_a[1]);
            } else if (match($0, "^ *(.*)\\\\$", trimmed_cont_line_a)) {
                gsub(" +$", "", trimmed_cont_line_a[1]);
                printf("%s ", trimmed_cont_line_a[1]);
            } else {
                match($0, "^ *(.*)$", trimmed_cont_line_a);
                print trimmed_cont_line_a[1];
                in_cpp_continuation=0;
            }
            next;
        } else {
            print;
        }
    }' "$1"
}

function check_do178_balance() {
    awk '
    BEGIN {
        ifdepth=0;
        do178depth = -1;
        exitval = 0;
    }
    function find_do178label(instr   ,do178label_offset, instr_a) {
        do178label_offset = index(instr, do178label " ");
        if (! do178label_offset)
            do178label_offset = index(instr, do178label "*");
        if (! do178label_offset)
            do178label_offset = index(instr, do178label ")");
        if (do178label_offset)
            return do178label;
        if (match(instr, "/\\* *!? *([a-zA-Z0-9_]+)", instr_a))
            return instr_a[1];
        else
            return "";
    }
    /^[ \t]*#[ \t]*if/ {
        ++ifdepth;
        if ($0 ~ "[ (]HAVE_DO178") {
            if (do178depth >= 0) {
                print "nested DO178 conditional at line " NR " in " FILENAME >"/dev/stderr";
                exitval = 1;
            } else {
                do178depth = ifdepth;
                match($0, "[ (](HAVE_DO178[^ )]*)");
                do178label = substr($0, RSTART + 1, RLENGTH);
            }
        }
        next;
    }
    /^[ \t]*#[ \t]*else/ {
        if (do178depth == ifdepth) {
            do178_else_label = find_do178label($0);
            if (! do178_else_label) {
                print "missing annotation at #else for DO178 conditional at line " NR " in " FILENAME >"/dev/stderr";
                exitval = 1;
            } else if (do178_else_label != do178label) {
                print "mismatched annotation \"" do178_else_label "\" at #else for DO178 conditional at line " NR " in " FILENAME >"/dev/stderr";
                exitval = 1;
            }
        }
        next;
    }
    /^[ \t]*#[ \t]*elif/ {
        if (do178depth == ifdepth) {
            print "#elif not allowed in DO178 construct at line " NR " in " FILENAME >"/dev/stderr";
            exitval = 1;
        }
        next;
    }
    /^[ \t]*#[ \t]*endif/ {
        if (do178depth == ifdepth) {
            do178_endif_label = find_do178label($0);
            if (! do178_endif_label) {
                print "missing annotation at #endif for DO178 conditional at line " NR " in " FILENAME >"/dev/stderr";
                exitval = 1;
            } else if (do178_endif_label != do178label) {
                print "mismatched annotation \"" do178_endif_label "\" at #endif for DO178 conditional at line " NR " in " FILENAME >"/dev/stderr";
                exitval = 1;
            }
            do178depth = -1;
        }
        --ifdepth;
        next;
    }
    END {
        if (exitval)
            exit(exitval);
        if (ifdepth == 0) {
            exit(0);
        } else {
            print "unbalanced ifdepth in " FILENAME >"/dev/stderr";
            exit(1);
        }
    }' "$1"
}

function build_filtered_settings() {
    declare -n out_settings=$1
    shift
    out_settings=()

    # Add all excluded defines as undefined
    for define in "${!excluded_defines[@]}"; do
        # Don't undefine anything that's in required_defines
        if [[ ! -v required_defines["$define"] ]]; then
            out_settings+=("-U${define}")
        fi
    done

    # Add remaining settings, excluding HAVE_CONFIG_H
    while [[ $# -gt 0 ]]; do
        local bare_variable=${1/-?/}
        bare_variable=${bare_variable%=*}
        # Skip HAVE_CONFIG_H and only include if:
        # 1. Not in excluded_defines
        # 2. Not in required_defines
        # 3. Not trying to undefine (-U) a required define
        if [[ "$bare_variable" != "HAVE_CONFIG_H" ]] && \
           [[ ! -v excluded_defines["$bare_variable"] ]] && \
           [[ ! -v required_defines["$bare_variable"] ]] && \
           ! { [[ "${1:0:2}" == "-U" ]] && [[ -v required_defines["${bare_variable#U}"] ]]; }; then
            out_settings+=("$1")
        fi
        shift
    done
    return 0
}

subdir_depth=0

declare -A seen_includes

function handle_make_output_line() {
    declare -n this_line="$1"
    local dest_tree="$2"
    declare -n filenames="$3"
    if [[ $# == 4 ]]; then
        local subdir_src_prefix="$4"
    fi

    case "$this_line" in
        *\ \&\&\\) this_line="${this_line:0:-4}" ;;
    esac

    if [[ -v subdir_src_prefix ]]; then
        case "$this_line" in
            gcc*\ +([-/a-zA-Z0-9_]).c\ *) ;;
            gcc*\ +([-/a-zA-Z0-9_]).c) ;;
            libtool:\ compile:\ \ gcc\ *) ;;
            +(.)\ /*.[ch]) return 0;;
            +(.)\ *.[ch]) seen_includes["$(realpath --relative-to=. "${this_line##+(.) "${subdir_src_prefix}"}")"]=''
                          return 0 ;;
            *) return 0;;
        esac
    else
        case "$this_line" in
            *Entering\ directory*) : $((++subdir_depth)); return 0;;
            *Leaving\ directory*) : $((--subdir_depth)); return 0;;
            gcc*\ +([-/a-zA-Z0-9_]).c\ *) ;;
            gcc*\ +([-/a-zA-Z0-9_]).c) ;;
            libtool:\ compile:\ \ gcc\ *) ;;
            +(.)\ /*.[ch]) return 0;;
            +(.)\ *.[ch]) seen_includes["$(realpath --relative-to=. "${this_line##+(.) *(./)}")"]=''
                          return 0;;
            *) return 0;;
        esac
    fi

    declare -a this_line_a
    read -r -a this_line_a < <(echo "$this_line")

    unset filename
    for word in "${this_line_a[@]}"; do
        if [[ "$word" =~ [-/a-zA-Z0-9_]+\.c ]]; then
            local filename="$word"
            break
        fi
    done

    if [[ -v subdir_src_prefix ]]; then
        filename="${filename#"${subdir_src_prefix}"}"
    fi

    # if the destination file is a symlink, exclude it from the trim.
    if [[ -h "${do178_filtered_tree}/${filename}" ]]; then
        return 0
    fi

    filename="$(realpath --relative-to=. "$filename")"

    filenames["$filename"]=

    if ! check_do178_balance "$filename"; then
        saw_errs=
        return 0
    fi

    local settings=()
    local arg

    for arg in "${this_line_a[@]}"; do
        arg=${arg//\"/}
        case "$arg" in
            # need to exclude HAVE_DO178_* (e.g. HAVE_DO178_STAGE2) and only retain the globally applicable HAVE_DO178:
            -DHAVE_DO178_*|-UHAVE_DO178_*) ;;

            # exclude stage-specific flags:
            -DBUILD_LOADER_STAGE1|-UBUILD_LOADER_STAGE1|-DTARGET_*) ;;

            # exclude debug flags set by .config:
            -DDEBUG*|-DWOLFBOOT_DEBUG*) ;;

            -D*|-U*) settings+=("$arg");;
        esac
    done

    join_cpp_line_continuations "$user_settings" | unifdef -x 2 -UH_USER_SETTINGS_ "${undefs[@]/#/-U}" "${settings[@]}" | filter_out_cpp_conditionals >| /tmp/wolfcrypt_user_settings_filtered.h.$$ || exit $?

    pcre2grep -o1 -e ' *# *define *([^ ()]+)( +1)? *$' /tmp/wolfcrypt_user_settings_filtered.h.$$ | sort -u | readarray -t userdefs
    rm /tmp/wolfcrypt_user_settings_filtered.h.$$ || exit $?

    mkdir -p "${dest_tree}/${filename%/*}" || exit $?

    build_filtered_settings filtered_settings "${always_settings[@]}" "${undefs[@]/#/-U}" "${settings[@]//\"/}" "${userdefs[@]/#/-D}"
    join_cpp_line_continuations "$filename" | unifdef -t -x 2 -k "${filtered_settings[@]}" > "${dest_tree}/${filename}" || { echo "${filename} processing failed with code $?" >&2; saw_errs=; }

    echo -n .

    return 0
}

if [[ ! -d "$do178_filtered_tree" ]]; then
    mkdir "$do178_filtered_tree" || exit $?
fi

echo "building wolfTPM:"
make --quiet clean >/dev/null || exit $?

# need to default all symbols in $user_settings to undefined
pcre2grep -o1 -e ' *# *ifn?def *([^ ]+)' -e '\bdefined\( *([^ \)]+) *\)' "$user_settings" | sort -u | readarray -t undefs || exit $?

# but nothing that's conditionally set by logic in $user_settings can
# be forced off by ${undefs[@]}, because unifdef doesn't function as an actual C
# preprocessor, i.e.  symbols forced undef from the command line would stay
# undef even if they would get #defined in $user_settings when processed by a
# true preprocessor.

pcre2grep -o1 -e ' *# *define *([^ ()]+)( |$)' "$user_settings" | sort -u | readarray -t maydefs_a || exit $?

declare -A maydefs_A
for def in "${maydefs_a[@]}"; do
    maydefs_A["$def"]=
done

for undef_i in "${!undefs[@]}"; do
    if [[ -v maydefs_A[${undefs[$undef_i]}] ]]; then
        unset 'undefs[$undef_i]'
    fi
done

echo -n "    make wolfTPM..."

# force off the jobserver to get a linear build log:
if [[ -f aminclude.am ]]; then
    mv aminclude.am aminclude.am.$$
    > aminclude.am
fi

make V=1 CC='gcc -H' 2>&1 | readarray -t make_out
make_result=$?

if [[ -f aminclude.am.$$ ]]; then
    mv aminclude.am.$$ aminclude.am
fi

if [[ $make_result != '0' ]]; then
    echo "${make_out[*]/%/
}" | tail
    exit $make_result
fi

echo

echo -n "postprocess stage2_filenames[]"
declare -A stage2_filenames
for line in "${make_out[@]}"; do
    handle_make_output_line line "/tmp/do178_filtered_tree.stage2.$$" stage2_filenames || exit $?
done
echo

# simple filter pass for include-only files (mostly headers).  keep these
# separate from stage2_filenames[] because cloc scores the headers all as zero.

header_filenames=()
for filename in "${!seen_includes[@]}"; do
    if [[ -h "${do178_filtered_tree}/${filename}" ]]; then
        echo "skipping include file ${filename} that is a symlink in the destination tree."
        continue
    fi
    if [[ -v stage2_filenames["$filename"] ]]; then
        echo "skipping include file ${filename} already processed as a directly compiled file."
        continue
    fi
    if ! check_do178_balance "$filename"; then
        saw_errs=
        continue
    fi
    header_filenames+=("$filename")
    mkdir -p "/tmp/do178_filtered_tree.stage2.$$/${filename%/*}" || exit $?
    build_filtered_settings header_settings "${always_settings[@]}" "${undefs[@]/#/-U}"
    join_cpp_line_continuations "$filename" | unifdef -t -x 2 -k "${header_settings[@]}" > "/tmp/do178_filtered_tree.stage2.$$/${filename}" || { echo "${filename} processing failed with code $?" >&2; saw_errs=; }
done

# error if any *.[ch] regular files are found in destination tree but missing from source tree:
find "${do178_filtered_tree}" -name '*.[ch]' -type f | readarray -t do178_filtered_tree_reg_files || exit $?
for filename in "${do178_filtered_tree_reg_files[@]}"; do
    filename="${filename##"${do178_filtered_tree}/"}"
    if [[ ! -v stage2_filenames[$filename] && ! -v seen_includes[$filename] && ! -v excluded_filenames[$filename] && ! -v ignore_unregen_filenames[$filename] ]]; then
        saw_errs=
        echo "found unregenerated (stale?) file \"${do178_filtered_tree}/${filename}\" in destination tree." >&2
    fi
done

# error if any symlinks in destination tree are dead:
find "${do178_filtered_tree}" -xtype l -ls | readarray dead_symlinks || exit $?
if [[ -v dead_symlinks ]]; then
    echo "dead symlinks found in ${do178_filtered_tree}:"
    echo -n "$dead_symlinks"
    saw_errs=
fi

if [[ -v saw_errs ]]; then
    echo "not updating destination tree ${do178_filtered_tree} due to previous error(s)." >&2
fi

for filename in "${!stage2_filenames[@]}" "${header_filenames[@]}"; do
    if [[ -v excluded_filenames[$filename] ]]; then
        continue
    fi
    if [[ -f "${do178_filtered_tree}/${filename}" ]]; then
        diff -q "/tmp/do178_filtered_tree.stage2.$$/${filename}" "${do178_filtered_tree}/${filename}" >/dev/null
        case $? in
            0) ;;
            1) if [[ -v saw_errs ]]; then
                   echo "would have updated ${do178_filtered_tree}/${filename}"
               else
                   mv "/tmp/do178_filtered_tree.stage2.$$/${filename}" "${do178_filtered_tree}/${filename}" || exit $?
                   echo "updated ${do178_filtered_tree}/${filename}"
               fi
               made_a_change=
               ;;
            *) exit $?
               ;;
        esac
    else
        if [[ -v saw_errs ]]; then
            echo "would have added ${do178_filtered_tree}/${filename}"
        else
            mkdir -p "${do178_filtered_tree}/${filename%/*}" || exit $?
            mv "/tmp/do178_filtered_tree.stage2.$$/${filename}" "${do178_filtered_tree}/${filename}" || exit $?
            echo "added ${do178_filtered_tree}/${filename}"
        fi
        made_a_change=
    fi
done

if [[ -v saw_errs ]]; then
    exit 1
fi

echo "regeneration complete."
if [[ ! -v made_a_change ]]; then
    echo "(no changes -- all files in ${do178_filtered_tree} were already up-to-date.)"
fi

echo
echo "trim statistics:"

printf "%-35s\t%s\t%s\t%s\n" "File" "pre-LOC" "postLOC" "trim"
(for filename in $(echo "${!stage2_filenames[@]}" | tr ' ' '\n' | sort); do
    if [[ -v excluded_filenames[$filename] ]]; then
        continue
    fi
    printf "%-35s\t%d\t%d\n" "${filename}" "$(cloc --force-lang-def "$cloc_lang_def" --quiet "$filename" | awk '/^C /{print $5}')" "$(cloc --force-lang-def "$cloc_lang_def" --quiet --hide-rate "${do178_filtered_tree}/${filename}" | awk '/^C /{print $5}')"
done) | awk '{pre+=$2; post+=$3; printf("%-35s\t%s\t%s\t%.1f%%\n",$1, $2, $3, $2 ? (-100.0 * (1.0 - $3 / $2)) : 0);}END{if (pre) { printf("%-35s\t%s\t%s\t%.1f%%\n","total", pre, post, -100.0 * (1.0 - post/pre)) } else { print "no trimmed files found."; exit(1); };}'
